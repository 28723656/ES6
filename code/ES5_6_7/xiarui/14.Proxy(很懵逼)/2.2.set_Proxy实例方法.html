<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<!--
Proxy
2020年3月15日19:27:02
-->

</body>
</html>


<script type="text/javascript">

    let log = (...filed) => {
        const { log } = console
        log('\t', ...filed)
    }

    // todo:熟悉，并且练习
    // proxy的所有操作
    /*
   -get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。
   -set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
   -has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。
   -deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。
   -ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
   -getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
   -defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
   -preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。
   -getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。
   -isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。
   -setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
   -apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
   -construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。
     */

    // set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。

    // todo: 这个也需要好好的复习一下下
    // 假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求。
    let validator = {
        set: function (obj, prop, value) {
            if (prop === 'age') {
                if (!Number.isInteger(value)) {
                    throw new TypeError('The age is not an integer')
                }
                if (value > 200) {
                    throw new RangeError('The age seems invalid')
                }
            }

            // 对于满足条件的 age 属性以及其他属性，直接保存
            obj[prop] = value
        }
    }

    let person = new Proxy({}, validator)

    person.age = 100

    person.age // 100
    person.age = 'young' // 报错
    person.age = 300 // 报错

    const handler = {
        get (target, key) {
            invariant(key, 'get');
            return target[key];
        },
        set (target, key, value) {
            invariant(key, 'set');
            target[key] = value;
            return true;
        }
    };
    function invariant (key, action) {
        if (key[0] === '_') {
            throw new Error(`Invalid attempt to ${action} private "${key}" property`);
        }
    }
    const target = {};
    const proxy = new Proxy(target, handler);
    proxy._prop
    // Error: Invalid attempt to get private "_prop" property
    proxy._prop = 'c'
    // Error: Invalid attempt to set private "_prop" property


    // set方法的第4个参数
    const handler2 = {
        set: function(obj, prop, value, receiver) {
            obj[prop] = receiver;
        }
    };
    const proxy2 = new Proxy({}, handler2);
    proxy2.foo = 'bar';
    proxy2.foo === proxy2 // true



    // homework: 1.搞清楚set属性每一个参数的意义
    //            2.利用set属性，比如obj.birth = 1996 的时候，console.log('你今年xx岁了'),并且所计算出的年龄必须是0-120之间，否则返回错误

</script>
